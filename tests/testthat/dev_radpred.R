# setMethod("radpred",signature(object="fitsad", sad="missing", rad="missing",
#                               coef="missing", trunc="missing", distr="missing", S="missing", N="missing"),
#           function (object){
#               ab = object@data$x
#               radpred(sad=object@sad, coef=as.list(bbmle::coef(object)),
#                       trunc=object@trunc, S=length(ab), N=sum(ab))
#           }
# )

# setMethod("radpred", signature(object="missing", sad="character", rad="missing",
#                                coef="list", trunc="ANY", distr="ANY", S="numeric", N="numeric"),
#           function(object, sad, rad, coef, trunc, distr=NA, S, N){

for (mm in mar:::.sad_models) {print(sads::distr(mm))}

library(sads)
moths.mzsm <- fitsad(moths, "mzsm")
vars = coef(moths.mzsm)
object = moths.mzsm
object = mzm

sad=object@sad
coef=as.list(bbmle::coef(object))
trunc=object@trunc
ab = object@data$x
S = length(ab)
N = sum(ab)


if(!is.na(distr)) warning("The parameter distr has been deprecated and is ignored, see ?distr")
distribution <- distr(sad)
if(missing(trunc)) trunc <- NaN
if (distribution == "discrete") {
    ## Approximates the [q] function instead of calling it directly to save some
    ## computational time (as [q] is inneficiently vectorized)
    y <- 1:N
    Y <- ppoints(S)
    if(!is.nan(trunc))
        X <- do.call(ptrunc, list(sad, q = y, coef = coef, lower.tail=F, trunc = trunc))
    else {
        psad <- get(paste("p", sad, sep=""), mode = "function")
        qsad <- get(paste("q", sad, sep=""), mode = "function")
        X <- do.call(psad, c(list(q = y, lower.tail = F), coef))
    }
    ab <- approx(x=c(1, X), y=c(0, y), xout=Y, method="constant")$y
    ## Extreme values of abundance are out of bounds for approx. Explicit form:
    for (i in 1:length(ab)) {
        if (!is.na(ab[i])) break;
        cat("Note: extreme values generated by radpred. Calculations will take a while...\n")
        if(! is.nan(trunc))
            ab[i] <- do.call(qtrunc, list(sad, p = Y[i], coef = coef, lower.tail=FALSE, trunc = trunc))
        else
            ab[i] <- do.call(qsad, c(list(p = Y[i], lower.tail=FALSE), coef))
    }
} else if(distribution == "continuous") {
    Y <- ppoints(S)
    if(!is.nan(trunc))
        ab <- do.call(qtrunc, list(sad, p = Y, coef = coef, lower.tail=F, trunc = trunc))
    else{
        qsad <- get(paste("q", sad, sep=""), mode = "function")
        ab <- do.call(qsad, c(list(p = Y, lower.tail = F), coef))
    }
} else
    stop("Please provide a valid distribution")
new("rad", data.frame(rank=1:S, abund=ab))
#           }
# )
